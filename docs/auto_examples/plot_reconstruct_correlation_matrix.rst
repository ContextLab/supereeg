

.. _sphx_glr_auto_examples_plot_reconstruct_correlation_matrix.py:


=============================
Model reconstruction by number of subjects and electrodes
=============================

In this example, we will parametrically vary how many subjects and how many
electrodes per subject are used to create the model.  First, we load in some
example locations.  Then, we simulate a correlation matrix (toeplitz) to impose
on the simulated subject data. Finally, we loop over number of subjects and
number of randomly chosen electrodes and plot the model at each iteration. As
the figure shows, the more subjects and electrodes, the better then recovery of
the true model.





.. image:: /auto_examples/images/sphx_glr_plot_reconstruct_correlation_matrix_001.png
    :align: center





.. code-block:: python


    # Code source: Andrew Heusser & Lucy Owen
    # License: MIT

    import scipy
    import numpy as np
    import os
    import pandas as pd
    import seaborn as sns
    import matplotlib.pyplot as plt
    import superEEG as se

    # load example model to get locations
    locs = se.load('example_locations')

    locs=pd.DataFrame(locs, columns=['x', 'y', 'z'])
    # simulate correlation matrix
    R = se.create_cov(cov='toeplitz', n_elecs=len(locs))

    # n_samples
    n_samples = 1000

    # initialize subplots
    f, axarr = plt.subplots(4, 4)

    # loop over simulated subjects size
    for isub, n_subs in enumerate([10, 25, 50, 100]):

        # loop over simulated electrodes
        for ielec, n_elecs in enumerate([10, 25, 50, 100]):

            # # initialize data list
            # data = []
            #
            # # loop over simulated subjects
            # for i in range(n_subs):
            #     # for each subject, randomly choose n_elecs electrode locations
            #     #p = np.random.choice(range(len(locs)), n_elecs, replace=False)
            #     p = locs.sample(n_elecs).sort_values(['x', 'y', 'z'])
            #     # generate some random data
            #     rand_dist = np.random.multivariate_normal(np.zeros(len(locs)), np.eye(len(locs)), size=n_samples)
            #
            #     # impose R correlational structure on the random data, create the brain object and append to data
            #     data.append(se.Brain(data=np.dot(rand_dist, scipy.linalg.cholesky(R))[:, p.index], locs=p))
            # # create the model object
            # model = se.Model(data=data, locs=locs)

            #### should I use this instead?? they give the same results

            # simulate brain objects for the model
            model_bos = [se.simulate_model_bos(n_samples=10000, sample_rate=1000, locs=locs, sample_locs=n_elecs, cov='toeplitz') for x in
                         range(n_subs)]

            # create the model object
            model = se.Model(data=model_bos, locs=locs)

            # plot it
            sns.heatmap(np.divide(model.numerator, model.denominator), ax=axarr[isub, ielec], yticklabels=False,
                        xticklabels=False, cmap='RdBu_r', cbar=False, vmin=0, vmax=3)

            # set the title
            axarr[isub, ielec].set_title(str(n_subs) + ' Subjects, ' + str(n_elecs) + ' Electrodes')

    plt.tight_layout()
    plt.show()

**Total running time of the script:** ( 11 minutes  25.888 seconds)



.. container:: sphx-glr-footer


  .. container:: sphx-glr-download

     :download:`Download Python source code: plot_reconstruct_correlation_matrix.py <plot_reconstruct_correlation_matrix.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: plot_reconstruct_correlation_matrix.ipynb <plot_reconstruct_correlation_matrix.ipynb>`

.. rst-class:: sphx-glr-signature

    `Generated by Sphinx-Gallery <http://sphinx-gallery.readthedocs.io>`_
